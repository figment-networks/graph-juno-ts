// Code generated by protoc-gen-as. DO NOT EDIT.
// versions:
// 	 protoc-gen-as v0.3.0-alpha.3
// 	 protoc        v3.20.1
// source: cosmwasm/wasm/v1/types.ts

import { Writer, Reader, Protobuf } from "as-proto";
import { google } from "../../../google";

@unmanaged
export class AccessTypeParam {
  static encode(message: AccessTypeParam, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.value);
  }

  static decode(reader: Reader, length: i32): AccessTypeParam {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AccessTypeParam();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  value: AccessType;

  constructor(value: AccessType = 0) {
    this.value = value;
  }
}

export function decodeAccessTypeParam(a: Uint8Array): AccessTypeParam {
  return Protobuf.decode<AccessTypeParam>(a, AccessTypeParam.decode);
}

export class AccessConfig {
  static encode(message: AccessConfig, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.permission);

    writer.uint32(18);
    writer.string(message.address);
  }

  static decode(reader: Reader, length: i32): AccessConfig {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AccessConfig();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.permission = reader.int32();
          break;

        case 2:
          message.address = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  permission: AccessType;
  address: string;

  constructor(permission: AccessType = 0, address: string = "") {
    this.permission = permission;
    this.address = address;
  }
}

export function decodeAccessConfig(a: Uint8Array): AccessConfig {
  return Protobuf.decode<AccessConfig>(a, AccessConfig.decode);
}

export class Params {
  static encode(message: Params, writer: Writer): void {
    const code_upload_access_ = message.code_upload_access;
    if (code_upload_access_ !== null) {
      writer.uint32(10);
      writer.fork();
      AccessConfig.encode(code_upload_access_, writer);
      writer.ldelim();
    }

    writer.uint32(16);
    writer.int32(message.instantiate_default_permission);
  }

  static decode(reader: Reader, length: i32): Params {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Params();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code_upload_access = AccessConfig.decode(reader, reader.uint32());
          break;

        case 2:
          message.instantiate_default_permission = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code_upload_access: AccessConfig | null;
  instantiate_default_permission: AccessType;

  constructor(code_upload_access: AccessConfig | null = null, instantiate_default_permission: AccessType = 0) {
    this.code_upload_access = code_upload_access;
    this.instantiate_default_permission = instantiate_default_permission;
  }
}

export function decodeParams(a: Uint8Array): Params {
  return Protobuf.decode<Params>(a, Params.decode);
}

export class CodeInfo {
  static encode(message: CodeInfo, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.code_hash);

    writer.uint32(18);
    writer.string(message.creator);

    const instantiate_config_ = message.instantiate_config;
    if (instantiate_config_ !== null) {
      writer.uint32(42);
      writer.fork();
      AccessConfig.encode(instantiate_config_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CodeInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CodeInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code_hash = reader.bytes();
          break;

        case 2:
          message.creator = reader.string();
          break;

        case 5:
          message.instantiate_config = AccessConfig.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code_hash: Uint8Array;
  creator: string;
  instantiate_config: AccessConfig | null;

  constructor(code_hash: Uint8Array = new Uint8Array(0), creator: string = "", instantiate_config: AccessConfig | null = null) {
    this.code_hash = code_hash;
    this.creator = creator;
    this.instantiate_config = instantiate_config;
  }
}

export function decodeCodeInfo(a: Uint8Array): CodeInfo {
  return Protobuf.decode<CodeInfo>(a, CodeInfo.decode);
}

export class ContractInfo {
  static encode(message: ContractInfo, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.code_id);

    writer.uint32(18);
    writer.string(message.creator);

    writer.uint32(26);
    writer.string(message.admin);

    writer.uint32(34);
    writer.string(message.label);

    const created_ = message.created;
    if (created_ !== null) {
      writer.uint32(42);
      writer.fork();
      AbsoluteTxPosition.encode(created_, writer);
      writer.ldelim();
    }

    writer.uint32(50);
    writer.string(message.ibc_port_id);

    const extension_ = message.extension;
    if (extension_ !== null) {
      writer.uint32(58);
      writer.fork();
      google.protobuf.Any.encode(extension_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ContractInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ContractInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code_id = reader.uint64();
          break;

        case 2:
          message.creator = reader.string();
          break;

        case 3:
          message.admin = reader.string();
          break;

        case 4:
          message.label = reader.string();
          break;

        case 5:
          message.created = AbsoluteTxPosition.decode(reader, reader.uint32());
          break;

        case 6:
          message.ibc_port_id = reader.string();
          break;

        case 7:
          message.extension = google.protobuf.Any.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code_id: u64;
  creator: string;
  admin: string;
  label: string;
  created: AbsoluteTxPosition | null;
  ibc_port_id: string;
  extension: google.protobuf.Any | null;

  constructor(
    code_id: u64 = 0,
    creator: string = "",
    admin: string = "",
    label: string = "",
    created: AbsoluteTxPosition | null = null,
    ibc_port_id: string = "",
    extension: google.protobuf.Any | null = null
  ) {
    this.code_id = code_id;
    this.creator = creator;
    this.admin = admin;
    this.label = label;
    this.created = created;
    this.ibc_port_id = ibc_port_id;
    this.extension = extension;
  }
}

export function decodeContractInfo(a: Uint8Array): ContractInfo {
  return Protobuf.decode<ContractInfo>(a, ContractInfo.decode);
}

export class ContractCodeHistoryEntry {
  static encode(message: ContractCodeHistoryEntry, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.operation);

    writer.uint32(16);
    writer.uint64(message.code_id);

    const updated_ = message.updated;
    if (updated_ !== null) {
      writer.uint32(26);
      writer.fork();
      AbsoluteTxPosition.encode(updated_, writer);
      writer.ldelim();
    }

    writer.uint32(34);
    writer.bytes(message.msg);
  }

  static decode(reader: Reader, length: i32): ContractCodeHistoryEntry {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ContractCodeHistoryEntry();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.operation = reader.int32();
          break;

        case 2:
          message.code_id = reader.uint64();
          break;

        case 3:
          message.updated = AbsoluteTxPosition.decode(reader, reader.uint32());
          break;

        case 4:
          message.msg = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  operation: ContractCodeHistoryOperationType;
  code_id: u64;
  updated: AbsoluteTxPosition | null;
  msg: Uint8Array;

  constructor(
    operation: ContractCodeHistoryOperationType = 0,
    code_id: u64 = 0,
    updated: AbsoluteTxPosition | null = null,
    msg: Uint8Array = new Uint8Array(0)
  ) {
    this.operation = operation;
    this.code_id = code_id;
    this.updated = updated;
    this.msg = msg;
  }
}

export function decodeContractCodeHistoryEntry(a: Uint8Array): ContractCodeHistoryEntry {
  return Protobuf.decode<ContractCodeHistoryEntry>(a, ContractCodeHistoryEntry.decode);
}

@unmanaged
export class AbsoluteTxPosition {
  static encode(message: AbsoluteTxPosition, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.block_height);

    writer.uint32(16);
    writer.uint64(message.tx_index);
  }

  static decode(reader: Reader, length: i32): AbsoluteTxPosition {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AbsoluteTxPosition();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.block_height = reader.uint64();
          break;

        case 2:
          message.tx_index = reader.uint64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  block_height: u64;
  tx_index: u64;

  constructor(block_height: u64 = 0, tx_index: u64 = 0) {
    this.block_height = block_height;
    this.tx_index = tx_index;
  }
}

export function decodeAbsoluteTxPosition(a: Uint8Array): AbsoluteTxPosition {
  return Protobuf.decode<AbsoluteTxPosition>(a, AbsoluteTxPosition.decode);
}

export class Model {
  static encode(message: Model, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    writer.uint32(18);
    writer.bytes(message.value);
  }

  static decode(reader: Reader, length: i32): Model {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Model();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.value = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  value: Uint8Array;

  constructor(key: Uint8Array = new Uint8Array(0), value: Uint8Array = new Uint8Array(0)) {
    this.key = key;
    this.value = value;
  }
}

export function decodeModel(a: Uint8Array): Model {
  return Protobuf.decode<Model>(a, Model.decode);
}

export enum AccessType {
  ACCESS_TYPE_UNSPECIFIED = 0,
  ACCESS_TYPE_NOBODY = 1,
  ACCESS_TYPE_ONLY_ADDRESS = 2,
  ACCESS_TYPE_EVERYBODY = 3,
}

export enum ContractCodeHistoryOperationType {
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3,
}
